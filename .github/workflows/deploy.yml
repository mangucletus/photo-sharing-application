name: Deploy Photo Sharing App

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: eu-west-1
  TF_VERSION: 1.5.0

jobs:
  terraform:
    name: 'Terraform Plan & Apply'
    runs-on: ubuntu-latest
    environment: production
    
    defaults:
      run:
        shell: bash
        working-directory: ./terraform

    steps:
    # Checkout the repository to the GitHub Actions runner
    - name: Checkout
      uses: actions/checkout@v4

    # Configure AWS credentials
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    # Install the latest version of Terraform CLI
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}
        terraform_wrapper: false

    # Initialize a new or existing Terraform working directory
    - name: Terraform Init
      run: |
        # Update backend configuration with the correct bucket name
        sed -i 's/cletus-photo-sharing-tfstate-bucket-2753/${{ secrets.TF_STATE_BUCKET }}/g' main.tf
        terraform init
        
        # Check if state file exists and list current resources
        echo "üìä Current Terraform state:"
        terraform state list || echo "No resources in state yet"

    # Import existing resources to avoid conflicts
    - name: Import Existing Resources
      continue-on-error: true
      run: |
        echo "üîÑ Importing existing AWS resources to avoid conflicts..."
        
        # Set variables
        PROJECT_PREFIX="photo-sharing-app-${{ github.ref == 'refs/heads/main' && 'prod' || 'dev' }}"
        
        # Function to safely import a resource
        import_resource() {
            local resource_type=$1
            local resource_name=$2
            local aws_resource_id=$3
            
            echo "Checking ${resource_type}.${resource_name}..."
            
            # Check if resource already exists in state
            if terraform state show "${resource_type}.${resource_name}" > /dev/null 2>&1; then
                echo "‚úÖ ${resource_type}.${resource_name} already in state"
                return 0
            fi
            
            # Try to import the resource
            if terraform import "${resource_type}.${resource_name}" "${aws_resource_id}" > /dev/null 2>&1; then
                echo "‚úÖ Successfully imported ${resource_type}.${resource_name}"
            else
                echo "‚ÑπÔ∏è  ${resource_type}.${resource_name} not found or already managed"
            fi
        }
        
        # Import CloudWatch Log Group
        import_resource "aws_cloudwatch_log_group" "api_gateway_logs" "/aws/apigateway/${PROJECT_PREFIX}"
        
        # Import IAM Roles
        import_resource "aws_iam_role" "api_gateway_role" "${PROJECT_PREFIX}-api-gateway-role"
        import_resource "aws_iam_role_policy" "api_gateway_policy" "${PROJECT_PREFIX}-api-gateway-role:${PROJECT_PREFIX}-api-gateway-policy"
        
        # Import Lambda functions
        import_resource "aws_lambda_function" "image_resizer" "${PROJECT_PREFIX}-image-resizer"
        import_resource "aws_lambda_function" "upload_handler" "${PROJECT_PREFIX}-upload-handler"
        import_resource "aws_lambda_function" "list_handler" "${PROJECT_PREFIX}-list-handler"
        
        # Import S3 buckets
        IMAGES_BUCKET=$(aws s3 ls | grep "${PROJECT_PREFIX}-images" | awk '{print $3}' | head -1 || echo "")
        THUMBNAILS_BUCKET=$(aws s3 ls | grep "${PROJECT_PREFIX}-thumbnails" | awk '{print $3}' | head -1 || echo "")
        FRONTEND_BUCKET=$(aws s3 ls | grep "${PROJECT_PREFIX}-frontend" | awk '{print $3}' | head -1 || echo "")
        
        if [ ! -z "$IMAGES_BUCKET" ]; then
            import_resource "aws_s3_bucket" "images" "$IMAGES_BUCKET"
        fi
        
        if [ ! -z "$THUMBNAILS_BUCKET" ]; then
            import_resource "aws_s3_bucket" "thumbnails" "$THUMBNAILS_BUCKET"
        fi
        
        if [ ! -z "$FRONTEND_BUCKET" ]; then
            import_resource "aws_s3_bucket" "frontend" "$FRONTEND_BUCKET"
        fi
        
        # Import DynamoDB table
        TABLE_NAME="${PROJECT_PREFIX}-images-metadata"
        if aws dynamodb describe-table --table-name "$TABLE_NAME" > /dev/null 2>&1; then
            import_resource "aws_dynamodb_table" "images_metadata" "$TABLE_NAME"
        fi
        
        echo "üéâ Import process completed"

    # Checks that all Terraform configuration files adhere to a canonical format
    - name: Terraform Format Check
      run: terraform fmt -check -recursive
      continue-on-error: true

    # Validates the configuration files in a directory
    - name: Terraform Validate
      run: terraform validate

    # Refresh state to ensure it's up to date
    - name: Terraform Refresh
      run: |
        echo "üîÑ Refreshing Terraform state..."
        terraform refresh -var-file="terraform.tfvars" || echo "Refresh completed with warnings"

    # Generates an execution plan for Terraform
    - name: Terraform Plan
      run: |
        echo "üìã Creating Terraform execution plan..."
        terraform plan -input=false -var-file="terraform.tfvars" -out=tfplan
        
        # Show plan summary
        echo "üìä Plan Summary:"
        terraform show -no-color tfplan | grep -E "(Plan:|No changes)" || echo "Plan created successfully"
      env:
        TF_VAR_project_name: photo-sharing-app
        TF_VAR_environment: ${{ github.ref == 'refs/heads/main' && 'prod' || 'dev' }}

    # Apply the Terraform plan (only on main branch)
    - name: Terraform Apply
      if: github.ref == 'refs/heads/main' && github.event_name == 'push'
      run: |
        echo "üöÄ Applying Terraform changes..."
        terraform apply -auto-approve tfplan
        
        # Backup the state after successful apply
        echo "üíæ Backing up Terraform state..."
        terraform state pull > terraform-state-backup-$(date +%Y%m%d-%H%M%S).json

    # Get Terraform outputs
    - name: Get Terraform Outputs
      if: github.ref == 'refs/heads/main' && github.event_name == 'push'
      id: terraform-outputs
      run: |
        echo "üì§ Extracting Terraform outputs..."
        echo "images_bucket=$(terraform output -raw images_bucket_name)" >> $GITHUB_OUTPUT
        echo "thumbnails_bucket=$(terraform output -raw thumbnails_bucket_name)" >> $GITHUB_OUTPUT
        echo "frontend_bucket=$(terraform output -raw frontend_bucket_name)" >> $GITHUB_OUTPUT
        echo "dynamodb_table=$(terraform output -raw dynamodb_table_name)" >> $GITHUB_OUTPUT
        echo "api_gateway_url=$(terraform output -raw api_gateway_url)" >> $GITHUB_OUTPUT
        echo "lambda_function_name=$(terraform output -raw lambda_function_name)" >> $GITHUB_OUTPUT
        echo "upload_handler_name=$(terraform output -raw upload_handler_function_name)" >> $GITHUB_OUTPUT
        echo "list_handler_name=$(terraform output -raw list_handler_function_name)" >> $GITHUB_OUTPUT
        echo "cognito_user_pool_id=$(terraform output -raw cognito_user_pool_id)" >> $GITHUB_OUTPUT
        echo "cognito_user_pool_client_id=$(terraform output -raw cognito_user_pool_client_id)" >> $GITHUB_OUTPUT
        echo "cognito_identity_pool_id=$(terraform output -raw cognito_identity_pool_id)" >> $GITHUB_OUTPUT
        echo "cognito_region=$(terraform output -raw cognito_region)" >> $GITHUB_OUTPUT

    # Package and deploy Lambda functions - FIXED requirements.txt filename
    - name: Deploy Lambda Functions
      if: github.ref == 'refs/heads/main' && github.event_name == 'push'
      run: |
        echo "‚ö° Deploying Lambda functions..."
        cd ../lambda
        
        # Verify requirements.txt exists with correct filename
        if [ ! -f "requirements.txt" ]; then
            echo "‚ùå requirements.txt not found!"
            ls -la
            exit 1
        fi
        
        # Install dependencies from the CORRECT filename
        pip install -r requirements.txt -t .
        
        # Create deployment package
        zip -r ../lambda_function.zip . -x "*.pyc" "__pycache__/*"
        
        # Verify zip was created
        if [ ! -f "../lambda_function.zip" ]; then
            echo "‚ùå Lambda deployment package not created!"
            exit 1
        fi
        
        # Update Lambda functions with error handling
        update_lambda() {
            local func_name=$1
            if [ ! -z "$func_name" ]; then
                echo "Updating function: $func_name"
                if aws lambda update-function-code \
                  --function-name "$func_name" \
                  --zip-file fileb://../lambda_function.zip \
                  --region ${{ env.AWS_REGION }}; then
                    echo "‚úÖ Successfully updated $func_name"
                else
                    echo "‚ùå Failed to update $func_name"
                fi
            fi
        }
        
        # Update all Lambda functions
        update_lambda "${{ steps.terraform-outputs.outputs.lambda_function_name }}"
        update_lambda "${{ steps.terraform-outputs.outputs.upload_handler_name }}"
        update_lambda "${{ steps.terraform-outputs.outputs.list_handler_name }}"

        # Update environment variables for Lambda functions
        if [ ! -z "${{ steps.terraform-outputs.outputs.lambda_function_name }}" ]; then
            aws lambda update-function-configuration \
              --function-name ${{ steps.terraform-outputs.outputs.lambda_function_name }} \
              --environment Variables="{THUMBNAIL_BUCKET=${{ steps.terraform-outputs.outputs.thumbnails_bucket }},THUMBNAIL_SIZE=150,DYNAMODB_TABLE=${{ steps.terraform-outputs.outputs.dynamodb_table }}}" \
              --region ${{ env.AWS_REGION }} || echo "Failed to update image resizer config"
        fi
        
        if [ ! -z "${{ steps.terraform-outputs.outputs.upload_handler_name }}" ]; then
            aws lambda update-function-configuration \
              --function-name ${{ steps.terraform-outputs.outputs.upload_handler_name }} \
              --environment Variables="{IMAGES_BUCKET=${{ steps.terraform-outputs.outputs.images_bucket }},THUMBNAIL_BUCKET=${{ steps.terraform-outputs.outputs.thumbnails_bucket }},DYNAMODB_TABLE=${{ steps.terraform-outputs.outputs.dynamodb_table }}}" \
              --region ${{ env.AWS_REGION }} || echo "Failed to update upload handler config"
        fi
        
        if [ ! -z "${{ steps.terraform-outputs.outputs.list_handler_name }}" ]; then
            aws lambda update-function-configuration \
              --function-name ${{ steps.terraform-outputs.outputs.list_handler_name }} \
              --environment Variables="{THUMBNAIL_BUCKET=${{ steps.terraform-outputs.outputs.thumbnails_bucket }},DYNAMODB_TABLE=${{ steps.terraform-outputs.outputs.dynamodb_table }}}" \
              --region ${{ env.AWS_REGION }} || echo "Failed to update list handler config"
        fi

    # Deploy Frontend with Cognito configuration - IMPROVED
    - name: Deploy Frontend
      if: github.ref == 'refs/heads/main' && github.event_name == 'push'
      run: |
        echo "üåê Deploying frontend..."
        cd ../frontend
        
        # Verify index.html exists
        if [ ! -f "index.html" ]; then
            echo "‚ùå index.html not found!"
            ls -la
            exit 1
        fi
        
        # Create a backup and working copy
        cp index.html index.html.bak
        
        # Debug: Show what we're replacing
        echo "üîç Configuration values:"
        echo "IMAGES_BUCKET: ${{ steps.terraform-outputs.outputs.images_bucket }}"
        echo "THUMBNAILS_BUCKET: ${{ steps.terraform-outputs.outputs.thumbnails_bucket }}"
        echo "API_GATEWAY_URL: ${{ steps.terraform-outputs.outputs.api_gateway_url }}"
        echo "COGNITO_USER_POOL_ID: ${{ steps.terraform-outputs.outputs.cognito_user_pool_id }}"
        
        # Replace placeholders in index.html with actual values
        sed -i "s/{{IMAGES_BUCKET}}/${{ steps.terraform-outputs.outputs.images_bucket }}/g" index.html
        sed -i "s/{{THUMBNAILS_BUCKET}}/${{ steps.terraform-outputs.outputs.thumbnails_bucket }}/g" index.html
        sed -i "s|{{API_GATEWAY_URL}}|${{ steps.terraform-outputs.outputs.api_gateway_url }}|g" index.html
        sed -i "s/{{AWS_REGION}}/${{ env.AWS_REGION }}/g" index.html
        sed -i "s/{{COGNITO_USER_POOL_ID}}/${{ steps.terraform-outputs.outputs.cognito_user_pool_id }}/g" index.html
        sed -i "s/{{COGNITO_USER_POOL_CLIENT_ID}}/${{ steps.terraform-outputs.outputs.cognito_user_pool_client_id }}/g" index.html
        sed -i "s/{{COGNITO_IDENTITY_POOL_ID}}/${{ steps.terraform-outputs.outputs.cognito_identity_pool_id }}/g" index.html
        
        # Verify replacements were made
        echo "üîç Checking if placeholders were replaced..."
        if grep -q "{{" index.html; then
            echo "‚ö†Ô∏è Warning: Some placeholders were not replaced:"
            grep "{{" index.html || true
        else
            echo "‚úÖ All placeholders were successfully replaced"
        fi
        
        # Upload to S3
        aws s3 sync . s3://${{ steps.terraform-outputs.outputs.frontend_bucket }}/ \
          --delete \
          --region ${{ env.AWS_REGION }} \
          --exclude "*.bak"
        
        echo "‚úÖ Frontend deployed successfully"

    # Output deployment information
    - name: Deployment Summary
      if: github.ref == 'refs/heads/main' && github.event_name == 'push'
      run: |
        echo "## Deployment Complete! üéâ" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### üìä Infrastructure Deployed:" >> $GITHUB_STEP_SUMMARY
        echo "- **Images Bucket**: ${{ steps.terraform-outputs.outputs.images_bucket }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Thumbnails Bucket**: ${{ steps.terraform-outputs.outputs.thumbnails_bucket }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Frontend Bucket**: ${{ steps.terraform-outputs.outputs.frontend_bucket }}" >> $GITHUB_STEP_SUMMARY
        echo "- **DynamoDB Table**: ${{ steps.terraform-outputs.outputs.dynamodb_table }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Image Resizer Lambda**: ${{ steps.terraform-outputs.outputs.lambda_function_name }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Upload Handler Lambda**: ${{ steps.terraform-outputs.outputs.upload_handler_name }}" >> $GITHUB_STEP_SUMMARY
        echo "- **List Handler Lambda**: ${{ steps.terraform-outputs.outputs.list_handler_name }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Cognito User Pool**: ${{ steps.terraform-outputs.outputs.cognito_user_pool_id }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### üåê Access Your App:" >> $GITHUB_STEP_SUMMARY
        echo "- **Website**: [Open App](https://${{ steps.terraform-outputs.outputs.frontend_bucket }}.s3-website.${{ env.AWS_REGION }}.amazonaws.com/)" >> $GITHUB_STEP_SUMMARY
        echo "- **API Gateway**: ${{ steps.terraform-outputs.outputs.api_gateway_url }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### üîê Authentication:" >> $GITHUB_STEP_SUMMARY
        echo "- **User Pool ID**: ${{ steps.terraform-outputs.outputs.cognito_user_pool_id }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Client ID**: ${{ steps.terraform-outputs.outputs.cognito_user_pool_client_id }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### üîß Debug Information:" >> $GITHUB_STEP_SUMMARY
        echo "- **AWS Region**: ${{ env.AWS_REGION }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Environment**: ${{ github.ref == 'refs/heads/main' && 'prod' || 'dev' }}" >> $GITHUB_STEP_SUMMARY

  security-scan:
    name: 'Security Scan'
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      
    - name: Run Terraform Security Scan
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'config'
        scan-ref: './terraform'
        format: 'sarif'
        output: 'trivy-results.sarif'
        
    - name: Upload Trivy scan results to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'